// Code generated by internal/codegen. DO NOT EDIT.

package msgpackconverter

import (
	"encoding/binary"
	"errors"
	"math"

	"github.com/hexon/fastmsgpack/internal"
)

func (c *converter) convertValue(data []byte) (int, error) {
	if len(data) < 1 {
		return 0, internal.ErrShortInput
	}
	if data[0] < 0xc0 {
		if data[0] <= 0x7f {
			return 1, c.appendInt(int(data[0]))
		}
		if data[0] <= 0x8f {
			return c.convertValue_map(data, 1, int(data[0]&0b00001111))
		}
		if data[0] <= 0x9f {
			return c.convertValue_array(data, 1, int(data[0]&0b00001111))
		}
		s := int(data[0]&0b00011111) + 1
		if len(data) < s {
			return 0, internal.ErrShortInput
		}
		return s, c.appendBytes(data[1:s])
	}
	if data[0] >= 0xe0 {
		return 1, c.appendInt(int(int8(data[0])))
	}
	switch data[0] {
	case 0xc0:
		return 1, c.write(nilBytes)
	case 0xc2:
		return 1, c.write(falseBytes)
	case 0xc3:
		return 1, c.write(trueBytes)
	case 0xc4:
		if len(data) < 2 {
			return 0, internal.ErrShortInput
		}
		s := int(data[1]) + 2
		if len(data) < s {
			return 0, internal.ErrShortInput
		}
		return s, c.appendBytes(data[2:s])
	case 0xc5:
		if len(data) < 3 {
			return 0, internal.ErrShortInput
		}
		s := int(binary.BigEndian.Uint16(data[1:3])) + 3
		if len(data) < s {
			return 0, internal.ErrShortInput
		}
		return s, c.appendBytes(data[3:s])
	case 0xc6:
		if len(data) < 5 {
			return 0, internal.ErrShortInput
		}
		s := int(binary.BigEndian.Uint32(data[1:5])) + 5
		if len(data) < s {
			return 0, internal.ErrShortInput
		}
		return s, c.appendBytes(data[5:s])
	case 0xc7:
		if len(data) < 3 {
			return 0, internal.ErrShortInput
		}
		s := int(data[1]) + 3
		if len(data) < s {
			return 0, internal.ErrShortInput
		}
		return s, c.convertValue_ext(data[3:s], int8(data[2]))
	case 0xc8:
		if len(data) < 4 {
			return 0, internal.ErrShortInput
		}
		s := int(binary.BigEndian.Uint16(data[1:3])) + 4
		if len(data) < s {
			return 0, internal.ErrShortInput
		}
		return s, c.convertValue_ext(data[4:s], int8(data[3]))
	case 0xc9:
		if len(data) < 6 {
			return 0, internal.ErrShortInput
		}
		s := int(binary.BigEndian.Uint32(data[1:5])) + 6
		if len(data) < s {
			return 0, internal.ErrShortInput
		}
		return s, c.convertValue_ext(data[6:s], int8(data[5]))
	case 0xca:
		if len(data) < 5 {
			return 0, internal.ErrShortInput
		}
		return 5, c.appendFloat32(math.Float32frombits(binary.BigEndian.Uint32(data[1:5])))
	case 0xcb:
		if len(data) < 9 {
			return 0, internal.ErrShortInput
		}
		return 9, c.appendFloat64(math.Float64frombits(binary.BigEndian.Uint64(data[1:9])))
	case 0xcc:
		if len(data) < 2 {
			return 0, internal.ErrShortInput
		}
		return 2, c.appendInt(int(data[1]))
	case 0xcd:
		if len(data) < 3 {
			return 0, internal.ErrShortInput
		}
		return 3, c.appendInt(int(binary.BigEndian.Uint16(data[1:3])))
	case 0xce:
		if len(data) < 5 {
			return 0, internal.ErrShortInput
		}
		return 5, c.appendInt(int(binary.BigEndian.Uint32(data[1:5])))
	case 0xcf:
		if len(data) < 9 {
			return 0, internal.ErrShortInput
		}
		return 9, c.appendInt(int(binary.BigEndian.Uint64(data[1:9])))
	case 0xd0:
		if len(data) < 2 {
			return 0, internal.ErrShortInput
		}
		return 2, c.appendInt(int(int8(data[1])))
	case 0xd1:
		if len(data) < 3 {
			return 0, internal.ErrShortInput
		}
		return 3, c.appendInt(int(int16(binary.BigEndian.Uint16(data[1:3]))))
	case 0xd2:
		if len(data) < 5 {
			return 0, internal.ErrShortInput
		}
		return 5, c.appendInt(int(int32(binary.BigEndian.Uint32(data[1:5]))))
	case 0xd3:
		if len(data) < 9 {
			return 0, internal.ErrShortInput
		}
		return 9, c.appendInt(int(int64(binary.BigEndian.Uint64(data[1:9]))))
	case 0xd4:
		if len(data) < 3 {
			return 0, internal.ErrShortInput
		}
		return 3, c.convertValue_ext(data[2:3], int8(data[1]))
	case 0xd5:
		if len(data) < 4 {
			return 0, internal.ErrShortInput
		}
		return 4, c.convertValue_ext(data[2:4], int8(data[1]))
	case 0xd6:
		if len(data) < 6 {
			return 0, internal.ErrShortInput
		}
		return 6, c.convertValue_ext(data[2:6], int8(data[1]))
	case 0xd7:
		if len(data) < 10 {
			return 0, internal.ErrShortInput
		}
		return 10, c.convertValue_ext(data[2:10], int8(data[1]))
	case 0xd8:
		if len(data) < 18 {
			return 0, internal.ErrShortInput
		}
		return 18, c.convertValue_ext(data[2:18], int8(data[1]))
	case 0xd9:
		if len(data) < 2 {
			return 0, internal.ErrShortInput
		}
		s := int(data[1]) + 2
		if len(data) < s {
			return 0, internal.ErrShortInput
		}
		return s, c.appendBytes(data[2:s])
	case 0xda:
		if len(data) < 3 {
			return 0, internal.ErrShortInput
		}
		s := int(binary.BigEndian.Uint16(data[1:3])) + 3
		if len(data) < s {
			return 0, internal.ErrShortInput
		}
		return s, c.appendBytes(data[3:s])
	case 0xdb:
		if len(data) < 5 {
			return 0, internal.ErrShortInput
		}
		s := int(binary.BigEndian.Uint32(data[1:5])) + 5
		if len(data) < s {
			return 0, internal.ErrShortInput
		}
		return s, c.appendBytes(data[5:s])
	case 0xdc:
		if len(data) < 3 {
			return 0, internal.ErrShortInput
		}
		return c.convertValue_array(data, 3, int(binary.BigEndian.Uint16(data[1:3])))
	case 0xdd:
		if len(data) < 5 {
			return 0, internal.ErrShortInput
		}
		return c.convertValue_array(data, 5, int(binary.BigEndian.Uint32(data[1:5])))
	case 0xde:
		if len(data) < 3 {
			return 0, internal.ErrShortInput
		}
		return c.convertValue_map(data, 3, int(binary.BigEndian.Uint16(data[1:3])))
	case 0xdf:
		if len(data) < 5 {
			return 0, internal.ErrShortInput
		}
		return c.convertValue_map(data, 5, int(binary.BigEndian.Uint32(data[1:5])))
	}
	return 0, errors.New("unexpected 0xc1")
}
