// Code generated by internal/codegen. DO NOT EDIT.

package fastmsgpack

import (
	"encoding/binary"
	"errors"
	"math"

	"github.com/hexon/fastmsgpack/internal"
)

func decodeValue(data []byte, opt internal.DecodeOptions) (any, int, error) {
	if len(data) < 1 {
		return nil, 0, internal.ErrShortInput
	}
	if data[0] < 0xc0 {
		if data[0] <= 0x7f {
			return int(data[0]), 1, nil
		}
		if data[0] <= 0x8f {
			return decodeValue_map(data, 1, int(data[0]&0b00001111), opt)
		}
		if data[0] <= 0x9f {
			return decodeValue_array(data, 1, int(data[0]&0b00001111), opt)
		}
		s := int(data[0]&0b00011111) + 1
		if len(data) < s {
			return nil, 0, internal.ErrShortInput
		}
		return internal.UnsafeStringCast(data[1:s]), s, nil
	}
	if data[0] >= 0xe0 {
		return int(int8(data[0])), 1, nil
	}
	switch data[0] {
	case 0xc0:
		return nil, 1, nil
	case 0xc2:
		return false, 1, nil
	case 0xc3:
		return true, 1, nil
	case 0xc4:
		if len(data) < 2 {
			return nil, 0, internal.ErrShortInput
		}
		s := int(data[1]) + 2
		if len(data) < s {
			return nil, 0, internal.ErrShortInput
		}
		return data[2:s], s, nil
	case 0xc5:
		if len(data) < 3 {
			return nil, 0, internal.ErrShortInput
		}
		s := int(binary.BigEndian.Uint16(data[1:3])) + 3
		if len(data) < s {
			return nil, 0, internal.ErrShortInput
		}
		return data[3:s], s, nil
	case 0xc6:
		if len(data) < 5 {
			return nil, 0, internal.ErrShortInput
		}
		s := int(binary.BigEndian.Uint32(data[1:5])) + 5
		if len(data) < s {
			return nil, 0, internal.ErrShortInput
		}
		return data[5:s], s, nil
	case 0xc7:
		if len(data) < 3 {
			return nil, 0, internal.ErrShortInput
		}
		s := int(data[1]) + 3
		if len(data) < s {
			return nil, 0, internal.ErrShortInput
		}
		ret, err := decodeValue_ext(data[3:s], int8(data[2]), opt)
		return ret, s, err
	case 0xc8:
		if len(data) < 4 {
			return nil, 0, internal.ErrShortInput
		}
		s := int(binary.BigEndian.Uint16(data[1:3])) + 4
		if len(data) < s {
			return nil, 0, internal.ErrShortInput
		}
		ret, err := decodeValue_ext(data[4:s], int8(data[3]), opt)
		return ret, s, err
	case 0xc9:
		if len(data) < 6 {
			return nil, 0, internal.ErrShortInput
		}
		s := int(binary.BigEndian.Uint32(data[1:5])) + 6
		if len(data) < s {
			return nil, 0, internal.ErrShortInput
		}
		ret, err := decodeValue_ext(data[6:s], int8(data[5]), opt)
		return ret, s, err
	case 0xca:
		if len(data) < 5 {
			return nil, 0, internal.ErrShortInput
		}
		return math.Float32frombits(binary.BigEndian.Uint32(data[1:5])), 5, nil
	case 0xcb:
		if len(data) < 9 {
			return nil, 0, internal.ErrShortInput
		}
		return math.Float64frombits(binary.BigEndian.Uint64(data[1:9])), 9, nil
	case 0xcc:
		if len(data) < 2 {
			return nil, 0, internal.ErrShortInput
		}
		return int(data[1]), 2, nil
	case 0xcd:
		if len(data) < 3 {
			return nil, 0, internal.ErrShortInput
		}
		return int(binary.BigEndian.Uint16(data[1:3])), 3, nil
	case 0xce:
		if len(data) < 5 {
			return nil, 0, internal.ErrShortInput
		}
		return int(binary.BigEndian.Uint32(data[1:5])), 5, nil
	case 0xcf:
		if len(data) < 9 {
			return nil, 0, internal.ErrShortInput
		}
		return int(binary.BigEndian.Uint64(data[1:9])), 9, nil
	case 0xd0:
		if len(data) < 2 {
			return nil, 0, internal.ErrShortInput
		}
		return int(int8(data[1])), 2, nil
	case 0xd1:
		if len(data) < 3 {
			return nil, 0, internal.ErrShortInput
		}
		return int(int16(binary.BigEndian.Uint16(data[1:3]))), 3, nil
	case 0xd2:
		if len(data) < 5 {
			return nil, 0, internal.ErrShortInput
		}
		return int(int32(binary.BigEndian.Uint32(data[1:5]))), 5, nil
	case 0xd3:
		if len(data) < 9 {
			return nil, 0, internal.ErrShortInput
		}
		return int(int64(binary.BigEndian.Uint64(data[1:9]))), 9, nil
	case 0xd4:
		if len(data) < 3 {
			return nil, 0, internal.ErrShortInput
		}
		ret, err := decodeValue_ext(data[2:3], int8(data[1]), opt)
		return ret, 3, err
	case 0xd5:
		if len(data) < 4 {
			return nil, 0, internal.ErrShortInput
		}
		ret, err := decodeValue_ext(data[2:4], int8(data[1]), opt)
		return ret, 4, err
	case 0xd6:
		if len(data) < 6 {
			return nil, 0, internal.ErrShortInput
		}
		ret, err := decodeValue_ext(data[2:6], int8(data[1]), opt)
		return ret, 6, err
	case 0xd7:
		if len(data) < 10 {
			return nil, 0, internal.ErrShortInput
		}
		ret, err := decodeValue_ext(data[2:10], int8(data[1]), opt)
		return ret, 10, err
	case 0xd8:
		if len(data) < 18 {
			return nil, 0, internal.ErrShortInput
		}
		ret, err := decodeValue_ext(data[2:18], int8(data[1]), opt)
		return ret, 18, err
	case 0xd9:
		if len(data) < 2 {
			return nil, 0, internal.ErrShortInput
		}
		s := int(data[1]) + 2
		if len(data) < s {
			return nil, 0, internal.ErrShortInput
		}
		return internal.UnsafeStringCast(data[2:s]), s, nil
	case 0xda:
		if len(data) < 3 {
			return nil, 0, internal.ErrShortInput
		}
		s := int(binary.BigEndian.Uint16(data[1:3])) + 3
		if len(data) < s {
			return nil, 0, internal.ErrShortInput
		}
		return internal.UnsafeStringCast(data[3:s]), s, nil
	case 0xdb:
		if len(data) < 5 {
			return nil, 0, internal.ErrShortInput
		}
		s := int(binary.BigEndian.Uint32(data[1:5])) + 5
		if len(data) < s {
			return nil, 0, internal.ErrShortInput
		}
		return internal.UnsafeStringCast(data[5:s]), s, nil
	case 0xdc:
		if len(data) < 3 {
			return nil, 0, internal.ErrShortInput
		}
		return decodeValue_array(data, 3, int(binary.BigEndian.Uint16(data[1:3])), opt)
	case 0xdd:
		if len(data) < 5 {
			return nil, 0, internal.ErrShortInput
		}
		return decodeValue_array(data, 5, int(binary.BigEndian.Uint32(data[1:5])), opt)
	case 0xde:
		if len(data) < 3 {
			return nil, 0, internal.ErrShortInput
		}
		return decodeValue_map(data, 3, int(binary.BigEndian.Uint16(data[1:3])), opt)
	case 0xdf:
		if len(data) < 5 {
			return nil, 0, internal.ErrShortInput
		}
		return decodeValue_map(data, 5, int(binary.BigEndian.Uint32(data[1:5])), opt)
	}
	return nil, 0, errors.New("unexpected " + internal.DescribeValue(data) + " when expecting any")
}

func DecodeType(data []byte) ValueType {
	if len(data) < 1 {
		return TypeInvalid
	}
	if data[0] < 0xc0 {
		if data[0] <= 0x7f {
			return TypeInt
		}
		if data[0] <= 0x8f {
			return TypeMap
		}
		if data[0] <= 0x9f {
			return TypeArray
		}
		return TypeString
	}
	if data[0] >= 0xe0 {
		return TypeInt
	}
	switch data[0] {
	case 0xc0:
		return TypeNil
	case 0xc2:
		return TypeBool
	case 0xc3:
		return TypeBool
	case 0xc4:
		return TypeBinary
	case 0xc5:
		return TypeBinary
	case 0xc6:
		return TypeBinary
	case 0xc7:
		if len(data) < 3 {
			return TypeInvalid
		}
		s := int(data[1]) + 3
		if len(data) < s {
			return TypeInvalid
		}
		return decodeType_ext(data[3:s], int8(data[2]))
	case 0xc8:
		if len(data) < 4 {
			return TypeInvalid
		}
		s := int(binary.BigEndian.Uint16(data[1:3])) + 4
		if len(data) < s {
			return TypeInvalid
		}
		return decodeType_ext(data[4:s], int8(data[3]))
	case 0xc9:
		if len(data) < 6 {
			return TypeInvalid
		}
		s := int(binary.BigEndian.Uint32(data[1:5])) + 6
		if len(data) < s {
			return TypeInvalid
		}
		return decodeType_ext(data[6:s], int8(data[5]))
	case 0xca:
		return TypeFloat32
	case 0xcb:
		return TypeFloat64
	case 0xcc:
		return TypeInt
	case 0xcd:
		return TypeInt
	case 0xce:
		return TypeInt
	case 0xcf:
		return TypeInt
	case 0xd0:
		return TypeInt
	case 0xd1:
		return TypeInt
	case 0xd2:
		return TypeInt
	case 0xd3:
		return TypeInt
	case 0xd4:
		if len(data) < 3 {
			return TypeInvalid
		}
		return decodeType_ext(data[2:3], int8(data[1]))
	case 0xd5:
		if len(data) < 4 {
			return TypeInvalid
		}
		return decodeType_ext(data[2:4], int8(data[1]))
	case 0xd6:
		if len(data) < 6 {
			return TypeInvalid
		}
		return decodeType_ext(data[2:6], int8(data[1]))
	case 0xd7:
		if len(data) < 10 {
			return TypeInvalid
		}
		return decodeType_ext(data[2:10], int8(data[1]))
	case 0xd8:
		if len(data) < 18 {
			return TypeInvalid
		}
		return decodeType_ext(data[2:18], int8(data[1]))
	case 0xd9:
		return TypeString
	case 0xda:
		return TypeString
	case 0xdb:
		return TypeString
	case 0xdc:
		return TypeArray
	case 0xdd:
		return TypeArray
	case 0xde:
		return TypeMap
	case 0xdf:
		return TypeMap
	}
	return TypeInvalid
}
